##### user
como pintar arrays com dsu

##### assistant
```md
Pintar arrays com DSU (Disjoint Set Union) geralmente envolve representar os elementos do array como nós em uma estrutura de conjuntos disjuntos.  A \"cor\" de um elemento é então representada pelo conjunto ao qual ele pertence.  A DSU permite mesclar conjuntos (ou seja, \"pintar\" elementos com a mesma cor) de forma eficiente.
Aqui está um exemplo de como você pode usar DSU para \"pintar\" um array:
\```python
class DSU:
def __init__(self, n):
self.parent = list(range(n))
self.size = [1] * n
def find(self, i):
if self.parent[i] == i:
return i
self.parent[i] = self.find(self.parent[i])
return self.parent[i]
def union(self, i, j):
root_i = self.find(i)
root_j = self.find(j)
if root_i != root_j:
if self.size[root_i] \u003c self.size[root_j]:
root_i, root_j = root_j, root_i
self.parent[root_j] = root_i
self.size[root_i] += self.size[root_j]
return True
return False
def pintar_array(arr, intervalos):
n = len(arr)
dsu = DSU(n)
for inicio, fim, cor in intervalos:
for i in range(inicio, fim + 1):
# Une todos os elementos dentro do intervalo à sua extremidade esquerda
dsu.union(inicio, i)
cores = {}
nova_cor = 0
arr_pintado = [0] * n
for i in range(n):
raiz = dsu.find(i)
if raiz not in cores:
cores[raiz] = nova_cor
nova_cor += 1
arr_pintado[i] = cores[raiz]
return arr_pintado
# Exemplo de uso
arr = [0] * 10
intervalos = [(1, 4, 1), (5, 7, 2), (0, 2, 3)]  # (inicio, fim, cor) - cor é ignorada, a cor final é determinada pela ordem de processamento e união dos intervalos
arr_pintado = pintar_array(arr, intervalos)
print(arr_pintado)
\```
**Explicação do código:**
1. **Classe DSU:** Implementa a estrutura de dados Disjoint Set Union com as operações `find` (para encontrar o representante do conjunto) e `union` (para unir dois conjuntos).
2. **Função `pintar_array`:**
- Inicializa uma instância da classe DSU com o tamanho do array.
- Itera pelos intervalos fornecidos.
- Para cada intervalo, une todos os elementos dentro do intervalo usando `dsu.union()`.  A união é sempre feita em relação ao primeiro elemento do intervalo, garantindo que todos os elementos do intervalo pertençam ao mesmo conjunto.
- Após processar todos os intervalos, atribui cores aos conjuntos.  A cor é determinada pela ordem em que os representantes dos conjuntos são encontrados.
- Retorna o array pintado.
**Observações importantes:**
* A \"cor\" no exemplo acima é representada por um inteiro.  Você pode adaptá-lo para usar cores reais (e.g., strings, tuplas RGB) facilmente.
* A cor final de um elemento é determinada pela ordem em que os intervalos são processados.  Se intervalos se sobrepõem, o último intervalo processado \"vence\" e determina a cor final dos elementos na sobreposição.
* O parâmetro `cor` nos intervalos de entrada é ignorado neste exemplo, pois a cor final é determinada pela lógica DSU e pela ordem de processamento.  Se você precisar usar a cor especificada no intervalo, precisará modificar a lógica para levar isso em consideração (por exemplo, usando um dicionário para mapear raízes DSU para cores).
Este exemplo demonstra como usar DSU para \"pintar\" um array com base em intervalos.  Você pode adaptar este código para diferentes cenários e requisitos específicos.
```

##### system
```sc-context
Computação/One for All/Artigos/Disjoint Set Union.md
```

##### user
resuma [[Disjoint Set Union]]

##### assistant
Com base em suas anotações sobre União de Conjuntos Disjuntos (DSU), aqui está um resumo:

DSU, também conhecido como Union-Find, é uma estrutura de dados que rastreia um conjunto de elementos particionados em um número de conjuntos disjuntos (não sobrepostos). Ele fornece três operações principais:

* **`make_set(v)`**: Cria um novo conjunto contendo apenas o elemento *v*.
* **`union_sets(a, b)`**: Mescla os conjuntos que contêm os elementos *a* e *b*.
* **`find_set(v)`**: Retorna um representante ou líder do conjunto que contém o elemento *v*.  Este representante é usado para verificar se dois elementos pertencem ao mesmo conjunto (`find_set(a) == find_set(b)`).

DSUs são comumente implementados usando uma representação de floresta disjunta, onde cada conjunto é uma árvore e a raiz da árvore é o representante do conjunto.  Para eficiência, duas otimizações principais são usadas:

* **Compressão de caminho**: Durante uma operação `find_set(v)`, todos os nós no caminho de *v* até a raiz têm seus pais definidos diretamente para a raiz, achatando a árvore.
* **União por tamanho/classificação**: Ao mesclar dois conjuntos, a árvore menor (por tamanho ou classificação, que é uma aproximação da altura) é anexada à árvore maior, evitando árvores longas e degeneradas.

Com ambas as otimizações, a complexidade de tempo amortizada de cada operação DSU se torna *O(α(n))*, onde *α(n)* é a função inversa de Ackermann, que cresce extremamente lentamente e pode ser considerada quase constante para propósitos práticos.

Além das operações básicas, os DSUs podem ser estendidos para armazenar informações adicionais nos conjuntos, como tamanho, distância até o representante ou paridade do comprimento do caminho.  Essas extensões permitem uma variedade de aplicações, incluindo:

* Encontrar componentes conectados em um gráfico.
* Encontrar componentes conectados em uma imagem.
* Pintar subarrays offline.
* Suporte a distâncias até o representante.
* Suporte à paridade do comprimento do caminho (por exemplo, verificação de bipartição online).
* Consulta de mínimo em intervalo offline (RMQ).
* Ancestral comum mais baixo offline (LCA) em uma árvore.

DSUs são uma estrutura de dados versátil e eficiente com uma ampla gama de aplicações em algoritmos e ciência da computação.