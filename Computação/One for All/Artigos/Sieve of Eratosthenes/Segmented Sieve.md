Segue da otimização “peneirando até a raiz” que não há necessidade de manter todo o array `is_prime[1…n]` o tempo todo. Para peneirar, basta manter os números primos até a raiz de   $n$ , ou seja, $prime[1… sqrt(n)]$, dividir o intervalo completo em blocos e peneirar cada bloco separadamente.
Seja   $s$  uma constante que determina o tamanho do bloco, então temos $\lceil {\frac n s} \rceil$  blocos no total, e o bloco $k$  ( $k = 0 ... \lfloor {\frac n s} \rfloor$ ) contém os números em um segmento $[ks; ks + s - 1]$. Podemos trabalhar em blocos por turnos, ou seja, para cada bloco $k$ passaremos por todos os números primos (de   $1$  a   $\sqrt n$ ) e realizaremos a peneiração usando eles. Vale ressaltar que temos que modificar um pouco a estratégia ao lidar com os primeiros números: primeiro, todos os números primos de   $[1; \sqrt n]$  não devem se remover; e segundo, os números   $0$  e   $1$  devem ser marcados como números não primos. Ao trabalhar no último bloco, não deve ser esquecido que o último número necessário $n$ não está necessariamente localizado no final do bloco.

[[Implementação - Segmented Sieve]]